Chapter 2
	• Scanning/lexing/Lexical analysis
		○ Token
	• Parsing
		○ Parser
	• Syntax trees/ ASTs
	• Binding/Resolution
	• Identifier and scope
	• Attributes (for a node in the tree)
	• Symbol table
	• Intermediate representation (IR)
		○ Control flow graph
		○ Static single-assignment
		○ Three-address code
	• Constant folding
	• Death code elimination

	• Code gen
	• P-code (Portable code) aka bytecode
	• Process virtual machines
	• Garbage collector
	• The runtime
	• Single pass compilers (Syntax directed translations
	• Tree walk interpreter
	• Transpilers (source-to-source compiler/transcompiler)
	• JIT compilers



Chapter 3
	• Reference counting
	• Tracing garbage collection (Garbage collection)
	• Closure function
	• Classes vs prototypes
	• Instance
	• Instantiation and initialization 
	• Pure object oriented programming language


Chapter 4
	• Scanning aka lexing/lexical analysis
	• Tokens
	• Error handling
	• Lexeme
	• Regexes for lexical grammar
	• Regular language
	• Lookahead
	• Maximal munch
